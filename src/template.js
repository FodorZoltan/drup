"use strict";

const dot = require("dot");
const fs = require("fs-promise");
const path = require("path");
const escapeRegex = require("escape-string-regexp");

const DEF_SEP = "<@>";
const EXT_COMMENT_TAG = {
  "config" : "#",
  "ini" : ";",
};

const DOT_SETTINGS = Object.assign({}, dot.templateSettings);
DOT_SETTINGS.strip = false;

class Template {

  constructor(templateFile) {
    this._templateFile = templateFile;
    this._definitions = [];
    this._extensions = [];

    this._comment = true;
  }

  static from(templateFile) {
    return new Template(templateFile);
  }

  comment(yes) {
    this._comment = yes;
    return this;
  }

  define(definitions) {
    this._definitions = this._definitions.concat(definitions);
    return this;
  }

  extend({data = {}, template: template}) {
    if (!template) {
      throw new Error("Extension template path is required.");
    }

    this._extensions.push({data, template});
    return this;
  }

  compile(data, destination = null) {
    return this._compileExtensions(data)
      .then((def) => {
        def = Object.assign(this._getDefinitionsObject(), def);

        return fs.readFile(this._templateFile)
          .catch((err) => {
            throw new Error(`Failed to read template file:\n${this._templateFile}\n${err}`);
          })
          .then((template) => {
            return this._compileSingle(template, data, def);
          });
      })
      .then((content) => {
        const filename = path.basename(this._templateFile).slice(0, -Template.EXT.length);

        if (this._comment) {
          const ext = filename.split(".").pop();
          let commentTag = "#";

          if (EXT_COMMENT_TAG.hasOwnProperty(ext)) {
            commentTag = EXT_COMMENT_TAG[ext];
          }

          content = commentTag + " <drup autogenerated file>\n\n" + content;
        }

        if (!destination) {
          return content;
        }

        return fs.ensureDir(destination).then(() => {
          return fs.writeFile(path.join(destination, filename), content);
        });
      });
  }

  _compileExtensions(data) {
    if (!this._extensions.length) {
      return Promise.resolve({});
    }

    let extPromises = [];
    const extDefinitionOutput = this._definitions
      .map((def) => `{{#def.${def}}}`)
      .join(DEF_SEP);

    this._extensions.forEach(({data: extData, template: extPath}) => {
      extData = Object.assign(extData, data);

      extPromises.push(
        fs.readFile(extPath)
          .catch((err) => {
            throw new Error(`Failed to read extension template file:\n${extPath}\n${err}`);
          })
          .then((template) => {
            return this._compileSingle(template + extDefinitionOutput, extData);
          })
      );
    });

    return Promise.all(extPromises)
      .then((extResults) => {
        let def = this._getDefinitionsObject();

        extResults.forEach((result) => {
          let defIndex = -1;
          result.split(DEF_SEP).forEach((defResult) => {
            if (defResult === "undefined") {
              return;
            }

            def[this._definitions[++defIndex]] += defResult;
          });
        });

        return def;
      });
  }

  _getDefinitionsObject() {
    return this._definitions.reduce((res, item) => {
      res[item] = "";
      return res;
    }, {});
  }

  _compileSingle(template, data = {}, def = {}) {
    return dot.template(template, DOT_SETTINGS, def)(data);
  }

}

Template.EXT = ".dot";
Template.EXT_REGEX = new RegExp(escapeRegex(Template.EXT) + "$");

module.exports = Template;
