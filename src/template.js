"use strict";

const dot = require("dot");
const fs = require("fs-promise");
const path = require("path");
const escapeRegex = require("escape-string-regexp");

const DEF_SEP = "<@>";
const EXT_COMMENT_TAG = {
  "config" : "#",
  "ini" : ";",
};

const DOT_SETTINGS = Object.assign({}, dot.templateSettings);
DOT_SETTINGS.strip = false;

/**
 * Template class to compile DOT files.
 */
class Template {

  /**
   * Template constructor.
   *
   * @param {string} templateFile
   *    Path to the template.
   */
  constructor(templateFile) {
    this._templateFile = templateFile;
    this._definitions = [];
    this._extensions = [];

    this._comment = true;
  }

  /**
   * Convenience constructor.
   *
   * @param {string} templateFile
   *    Path to the template.
   *
   * @returns {Template}
   */
  static from(templateFile) {
    return new Template(templateFile);
  }

  /**
   * Set whether to add the auto-generated comment.
   *
   * @param {boolean} yes
   *    TRUE=add FALSE=don't add.
   * @param {string} commentChar
   *    Override for automatically detected comment character.
   *
   * @returns {Template}
   */
  comment(yes, commentChar) {
    this._comment = yes;

    if (commentChar) {
      this._commentCharacter = commentChar;
    }

    return this;
  }

  /**
   * Registers definitions.
   *
   * @param {string[]} definitions
   *
   * @returns {Template}
   */
  define(definitions) {
    this._definitions = this._definitions.concat(definitions);
    return this;
  }

  /**
   * Adds an extension template.
   *
   * @param {Object} data
   *    Data to send to template.
   * @param {string} template
   *    The template file path.
   *
   * @returns {Template}
   */
  extend({data = {}, template: template}) {
    if (!template) {
      throw new Error("Extension template path is required.");
    }

    this._extensions.push({data, template});
    return this;
  }

  /**
   * Compiles the template to given destination.
   *
   * @param {Object} data
   *    Data to send to template.
   * @param {string} destination
   *    Where to place the compiled file.
   *
   * @returns {Promise}
   */
  compile(data, destination = null) {
    // Compile extensions and accumulate definition content.
    return this._compileExtensions(data)
      .then((def) => {
        def = Object.assign(this._getDefinitionsObject(), def);

        // Read the main template and compile it.
        return fs.readFile(this._templateFile)
          .catch((err) => {
            throw new Error(`Failed to read template file:\n${this._templateFile}\n${err}`);
          })
          .then((template) => {
            return this._compileSingle(template, data, def);
          });
      })
      .then((content) => {
        // Remove DOT template extension from filename.
        const filename = path.basename(this._templateFile).slice(0, -Template.EXT.length);

        // Add auto-generated comment if enabled.
        if (this._comment) {
          const ext = filename.split(".").pop();
          let commentTag = "#";

          if (EXT_COMMENT_TAG.hasOwnProperty(ext)) {
            commentTag = EXT_COMMENT_TAG[ext];
          }

          if (this._commentCharacter) {
            commentTag = this._commentCharacter;
          }

          content = commentTag + " <drup autogenerated file>\n\n" + content;
        }

        if (!destination) {
          return content;
        }

        return fs.ensureDir(destination).then(() => {
          return fs.writeFile(path.join(destination, filename), content);
        });
      });
  }

  /**
   * Compiles extensions for this template.
   *
   * @param {Object} data
   *    Data to send to extension templates.
   * @returns {Promise}
   * @resolve {Object}
   *    Object of the result definitions data.
   * @private
   */
  _compileExtensions(data) {
    if (!this._extensions.length) {
      return Promise.resolve({});
    }

    let extPromises = [];
    const extDefinitionOutput = this._definitions
      .map((def) => `{{#def.${def}}}`)
      .join(DEF_SEP);

    this._extensions.forEach(({data: extData, template: extPath}) => {
      extData = Object.assign(extData, data);

      extPromises.push(
        fs.readFile(extPath)
          .catch((err) => {
            throw new Error(`Failed to read extension template file:\n${extPath}\n${err}`);
          })
          .then((template) => {
            return this._compileSingle(template + extDefinitionOutput, extData);
          })
      );
    });

    return Promise.all(extPromises)
      .then((extResults) => {
        let def = this._getDefinitionsObject();

        extResults.forEach((result) => {
          let defIndex = -1;
          result.split(DEF_SEP).forEach((defResult) => {
            if (defResult === "undefined") {
              return;
            }

            def[this._definitions[++defIndex]] += defResult;
          });
        });

        return def;
      });
  }

  /**
   * Creates definition object.
   *
   * @returns {Object}
   *    Empty definitions data.
   * @private
   */
  _getDefinitionsObject() {
    return this._definitions.reduce((res, item) => {
      res[item] = "";
      return res;
    }, {});
  }

  /**
   * Compiles a single template with given data.
   *
   * @param {string} template
   *    Template data.
   * @param data
   *    Data to send to compilation.
   * @param {Object} def
   *    Definitions data.
   *
   * @returns {string}
   *    Compiled template.
   * @private
   */
  _compileSingle(template, data = {}, def = {}) {
    return dot.template(template, DOT_SETTINGS, def)(data);
  }

}

Template.EXT = ".dot";
Template.EXT_REGEX = new RegExp(escapeRegex(Template.EXT) + "$");

module.exports = Template;
